package ru.espepe.bubuka.player.dao;

import ru.espepe.bubuka.player.dao.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table PLAY.
 */
public class Play {

    private Long id;
    private String name;
    private Integer volume;
    private Integer time;
    private String font;
    private String fontnew;
    private Boolean anim;
    private Integer period;
    private Long timelist_id;
    private Long block_id;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient PlayDao myDao;

    private Timelist timelist;
    private Long timelist__resolvedKey;

    private Block block;
    private Long block__resolvedKey;


    public Play() {
    }

    public Play(Long id) {
        this.id = id;
    }

    public Play(Long id, String name, Integer volume, Integer time, String font, String fontnew, Boolean anim, Integer period, Long timelist_id, Long block_id) {
        this.id = id;
        this.name = name;
        this.volume = volume;
        this.time = time;
        this.font = font;
        this.fontnew = fontnew;
        this.anim = anim;
        this.period = period;
        this.timelist_id = timelist_id;
        this.block_id = block_id;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getPlayDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getVolume() {
        return volume;
    }

    public void setVolume(Integer volume) {
        this.volume = volume;
    }

    public Integer getTime() {
        return time;
    }

    public void setTime(Integer time) {
        this.time = time;
    }

    public String getFont() {
        return font;
    }

    public void setFont(String font) {
        this.font = font;
    }

    public String getFontnew() {
        return fontnew;
    }

    public void setFontnew(String fontnew) {
        this.fontnew = fontnew;
    }

    public Boolean getAnim() {
        return anim;
    }

    public void setAnim(Boolean anim) {
        this.anim = anim;
    }

    public Integer getPeriod() {
        return period;
    }

    public void setPeriod(Integer period) {
        this.period = period;
    }

    public Long getTimelist_id() {
        return timelist_id;
    }

    public void setTimelist_id(Long timelist_id) {
        this.timelist_id = timelist_id;
    }

    public Long getBlock_id() {
        return block_id;
    }

    public void setBlock_id(Long block_id) {
        this.block_id = block_id;
    }

    /** To-one relationship, resolved on first access. */
    public Timelist getTimelist() {
        Long __key = this.timelist_id;
        if (timelist__resolvedKey == null || !timelist__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TimelistDao targetDao = daoSession.getTimelistDao();
            Timelist timelistNew = targetDao.load(__key);
            synchronized (this) {
                timelist = timelistNew;
            	timelist__resolvedKey = __key;
            }
        }
        return timelist;
    }

    public void setTimelist(Timelist timelist) {
        synchronized (this) {
            this.timelist = timelist;
            timelist_id = timelist == null ? null : timelist.getId();
            timelist__resolvedKey = timelist_id;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Block getBlock() {
        Long __key = this.block_id;
        if (block__resolvedKey == null || !block__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            BlockDao targetDao = daoSession.getBlockDao();
            Block blockNew = targetDao.load(__key);
            synchronized (this) {
                block = blockNew;
            	block__resolvedKey = __key;
            }
        }
        return block;
    }

    public void setBlock(Block block) {
        synchronized (this) {
            this.block = block;
            block_id = block == null ? null : block.getId();
            block__resolvedKey = block_id;
        }
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
